package car.auction.datasource;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import car.auction.auth.AppSession;
import car.auction.concurrency.LockManager;
import car.auction.domain.BiddingCar;
import car.auction.domain.User;

public class BiddingCarLockMapper {
	
	private LockManager lm;	// lock manager
	private String sessionStr; 
	
	// Get all cars where the price field has not been set, this means the car has not been sold
	private static final String getAllCarsStatement = "SELECT * FROM APP.car"
			+ " WHERE price IS NULL";
	
	private static final String getAllSoldCarsStatement = "SELECT * FROM APP.car"
			+ " WHERE price IS NOT NULL";
	
	// Get all cars, that has NOT been sold, by id 
	private static final String getCarByIdStatement = "SELECT * FROM APP.car"
			+ " WHERE id = ? "
			+ " AND price IS NULL";
	
	// Update basic car information
	private static final String updateCarStatementString = "UPDATE APP.car"
			+ " SET regno = ?, make = ?, model = ?, variant = ?, buildyear = ?"
			+ " WHERE id = ?";
	
	//  Update bid on a car
	private static final String updateBidStatementString = "UPDATE APP.car "
			+ "SET currentbid = ?, buyerID = ?"
			+ " WHERE id = ?";
	
	// Add new car to the auction
	private static final String insertStatementString =
            "INSERT INTO APP.car(regno, make, model, variant, buildyear, salesdate, currentbid)"
            + " VALUES (?, ?, ?, ?, ?, ?, ?)";
	
	// Delete car from auction by id
	private static final String deleteStatementString =
    		"DELETE FROM APP.car"
    		+ " WHERE id = ?";
	
	// Set the highest currentbid as the price of the car. The price field is used to check if a car has been sold or not
	private static final String updateCarSalesPriceStatementString =
			"UPDATE APP.car"
					+ " SET price = ?"
					+ " WHERE id = ?";

	// singleton
	private static final BiddingCarLockMapper instance = new BiddingCarLockMapper();

	private BiddingCarLockMapper() {
		this.lm = LockManager.getInstance();
		this.sessionStr = "bidding";
	}
	
	public static BiddingCarLockMapper getInstance(){
        return instance;
    }
	
	// Update basic car information
	public boolean updateCarInfo(BiddingCar cb) {
		PreparedStatement updateStatement = null;
		boolean noError = true;
		
		try {
			lm.acquireWriteLock(sessionStr);
		} catch (InterruptedException e1) {
			System.out.println("Acquiring write lock when adding when getting cars failed");
		}
		
		try {
			updateStatement = DBConnection.prepare(updateCarStatementString);
			
			updateStatement.setString(1, cb.getRegisterNumber());
			updateStatement.setString(2, cb.getMake());
			updateStatement.setString(3, cb.getModel());
			updateStatement.setString(4, cb.getVariant());
			updateStatement.setInt(5, cb.getYear());
			updateStatement.setInt(6, cb.getId());
			
			updateStatement.execute();
			DBConnection.dbConnection.commit();
			
		} catch (Exception e) {
			try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				noError = false;
			}
        }
		
		lm.releaseWriteLock(sessionStr);
		
		return noError;
	}
	
	// Update bid by car id
	public boolean updateBid(float currentbid, int id, int buyerID) {
		PreparedStatement updateStatement = null;
		boolean noError = true;
		
		try {
			lm.acquireWriteLock(sessionStr);
		} catch (InterruptedException e1) {
			System.out.println("Acquiring write lock when adding when getting cars failed");
		}
		
		try {
			updateStatement = DBConnection.prepare(updateBidStatementString);
			
			updateStatement.setFloat(1, currentbid);
			updateStatement.setInt(2, buyerID);
			updateStatement.setInt(3, id);
			
			updateStatement.execute();
			DBConnection.dbConnection.commit();
			
		} catch (Exception e) {
			try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				noError = false;
			}
        } 
		
		lm.releaseWriteLock(sessionStr);
		
		return noError;
	}
	
	// Add new car to the auction
	public boolean insert(BiddingCar cb) {
		ResultSet autoGenerated = null;
		PreparedStatement insertStatement = null;
		boolean noError = true;
		
		try {
			lm.acquireWriteLock(sessionStr);
		} catch (InterruptedException e1) {
			System.out.println("Acquiring write lock when adding when getting cars failed");
		}
		
		try {
			insertStatement = DBConnection.prepare(insertStatementString, Statement.RETURN_GENERATED_KEYS);
			
			insertStatement.setString(1, cb.getRegisterNumber());
			insertStatement.setString(2, cb.getMake());
			insertStatement.setString(3, cb.getModel());
			insertStatement.setString(4, cb.getVariant());
			insertStatement.setInt(5, cb.getYear());
			insertStatement.setLong(6, cb.getEndtime());
			insertStatement.setFloat(7, cb.getCurrentBid());
			
			insertStatement.executeUpdate();
			DBConnection.dbConnection.commit();
			
			autoGenerated = insertStatement.getGeneratedKeys();
            if (autoGenerated.next()) {
                cb.setId(autoGenerated.getInt(1));
            }
            
		} catch (SQLException e) {
			try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				noError = false;
			}
        } 
		
		lm.releaseWriteLock(sessionStr);
		
		return noError;
	}
	
	// delete car from database
    public boolean delete(int id) {
    	PreparedStatement deleteStatement = null;
    	boolean noError = true;
    	
		try {
			lm.acquireWriteLock(sessionStr);
		} catch (InterruptedException e1) {
			System.out.println("Acquiring write lock when adding when getting cars failed");
		}
    	
    	try {
    		deleteStatement = DBConnection.prepare(deleteStatementString);
    		deleteStatement.setInt(1, id);
    		
    		deleteStatement.execute();
    		DBConnection.dbConnection.commit();
    	} catch (SQLException e) {
    		try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				noError = false;;
			}
        } 
    	
    	lm.releaseWriteLock(sessionStr);
    	
    	return noError;
    }  
	
    // Get all cars for the auction list
	public static List<BiddingCar> getAllCars(){
		List<BiddingCar> result = new ArrayList<>();
		
		try {
			PreparedStatement stmt = DBConnection.prepare(getAllCarsStatement);
			
			ResultSet rs = stmt.executeQuery();
			DBConnection.dbConnection.commit();
			
			while (rs.next()) {
				BiddingCar car = new BiddingCar (rs.getInt(1), rs.getInt(2), rs.getString(3), rs.getString(4), rs.getString(5),
						rs.getString(6), rs.getInt(7), rs.getLong(9), rs.getFloat(10));
				
				result.add(car);
			}
			
		} catch (SQLException e) {
			try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				result = null;
			}
        }
		
		return result;
	}
	
	// Get all cars for the auction list
	public static List<BiddingCar> getAllHistoryCars(){
		List<BiddingCar> result = new ArrayList<>();

		try {
			PreparedStatement stmt = DBConnection.prepare(getAllSoldCarsStatement);
			
			ResultSet rs = stmt.executeQuery();
			DBConnection.dbConnection.commit();
			
			while (rs.next()) {
				BiddingCar car = new BiddingCar (rs.getInt(1), rs.getInt(2), rs.getString(3), rs.getString(4), rs.getString(5),
						rs.getString(6), rs.getInt(7), rs.getLong(9), rs.getFloat(10));
				
				result.add(car);
			}
			
		} catch (SQLException e) {
			try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				result = null;
			}
        }
		
		return result;
	}
	

	// get car information by id
	public BiddingCar getCarById(int id) {
        BiddingCar result = null;
        PreparedStatement getStatement = null;
        ResultSet rs = null;
        
		try {
			lm.acquireReadLock(sessionStr);
		} catch (InterruptedException e1) {
			System.out.println("Acquiring read lock when adding when getting cars failed");
		}
        
        try {
            getStatement = DBConnection.prepare(getCarByIdStatement);
            getStatement.setInt(1, id);
            rs = getStatement.executeQuery();
            DBConnection.dbConnection.commit();
            
            while (rs.next()) {
            	BiddingCar bc = new BiddingCar (rs.getInt(1), rs.getInt(2), rs.getString(3), rs.getString(4), rs.getString(5),
						rs.getString(6), rs.getInt(7), rs.getLong(9), rs.getFloat(10));
          	
            	result = bc;
            }

        } catch (SQLException e) {
        	try {
				DBConnection.dbConnection.rollback();
			} catch (SQLException ignored) {
				System.out.println("Rollback failed");
				result = null;
			}
        }
        
        lm.releaseReadLock(sessionStr);
        
        return result;
    }
	
	// Update car sales price by id
	public static void updatePrice(int id, float price) {
		PreparedStatement updateStatement = null;
		
		try {
			updateStatement = DBConnection.prepare(updateCarSalesPriceStatementString);
			
			updateStatement.setFloat(1, price);
			updateStatement.setInt(2, id);
			
			updateStatement.execute();
			DBConnection.dbConnection.commit();
			
		} catch (SQLException e) {
			System.out.println("update error: " + e.getMessage());
		
		}

	}
}
